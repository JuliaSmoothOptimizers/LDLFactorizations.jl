var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [LDLFactorizations]","category":"page"},{"location":"reference/#LDLFactorizations.LDLFactorization","page":"Reference","title":"LDLFactorizations.LDLFactorization","text":"Type that contains the LDLᵀ factorization of a matrix.\n\nThe components of the factorization can be accessed via getproperty:\n\nLDL.L: L sparse lower triangular factor of the factorization without the diagonal    of ones that is removed to save space\nLDL.D: D diagonal matrix of the factorization.\n\nIn order to avoid zero pivots during the factorization, the user can regularize the matrix by modifying  LDL.r1 for the LDL.n_d first pivots and LDL.r2 for the other pivots with tolerance LDL.tol.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.:--Union{Tuple{LDLFactorizations.LDLFactorization{Tf, Ti, Tn, Tp}}, Tuple{Tp}, Tuple{Tn}, Tuple{Ti}, Tuple{Tf}} where {Tf<:Real, Ti<:Integer, Tn<:Integer, Tp<:Integer}","page":"Reference","title":"Base.:-","text":"-(LDL)\n\nUnary minus operator returns an LDLFactorization with -LDL.d.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:\\-Union{Tuple{Tp}, Tuple{Tn}, Tuple{Ti}, Tuple{Tf}, Tuple{T}, Tuple{LDLFactorizations.LDLFactorization{Tf, Ti, Tn, Tp}, AbstractVector{T}}} where {T<:Real, Tf<:Real, Ti<:Integer, Tn<:Integer, Tp<:Integer}","page":"Reference","title":"Base.:\\","text":"x = LDL \\ b\n\nIf LDL is the LDLᵀ factorization of A, solves A x = b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LDLFactorizations.col_num!-NTuple{6, Any}","page":"Reference","title":"LDLFactorizations.col_num!","text":"col_num!(n, Ap, Ai, Ci, w, Pinv)\n\nCompute the rowval and values of missing elements of the upper triangle of PAPt. Nonzero elements have to verify Pinv[i] ≥ Pinv[j] where i is the row index and j the column index. Those elements are the nonzeros of the lower triangle of A that will be in the upper triangle of PAPt (after permutation)\n\nArguments\n\nn::Ti: number of columns of the matrix\nAp::Vector{Ti}: colptr of the matrix to factorize (CSC format)\nAi::Vector{Ti}: rowval of the matrix to factorize (CSC format)\nCi::Vector{Ti}: rowval of the lower triangle\nw::Vector{Ti}: work array\nPinv::Vector{Ti}: inverse permutation of P. PAPt is the matrix to factorize (CSC format)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LDLFactorizations.col_symb!-NTuple{6, Any}","page":"Reference","title":"LDLFactorizations.col_symb!","text":"col_symb!(n, Ap, Ai, Cp, w, Pinv)\n\nCompute the sparse structure of missing elements of the upper triangle of PAPt. Nonzero elements have to verify Pinv[i] < Pinv[j] where i is the row index and j the column index. Those elements are the nonzeros of the lower triangle of A that will be in the upper triangle of PAPt (after permutation)\n\nArguments\n\nn::Ti: number of columns of the matrix\nAp::Vector{Ti}: colptr of the matrix to factorize (CSC format)\nAi::Vector{Ti}: rowval of the matrix to factorize (CSC format)\nCp::Vector{Ti}: colptr of the lower triangle (to be modified)\nw::Vector{Ti}: work array\nPinv::Vector{Ti}: inverse permutation of P. PAPt is the matrix to factorize (CSC format)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LDLFactorizations.factorized-Union{Tuple{LDLFactorizations.LDLFactorization{T, Ti, Tn, Tp}}, Tuple{Tp}, Tuple{Tn}, Tuple{Ti}, Tuple{T}} where {T<:Real, Ti<:Integer, Tn<:Integer, Tp<:Integer}","page":"Reference","title":"LDLFactorizations.factorized","text":"isfact = factorized(LDL)\n\nReturns true if the most recent factorization stored in LDL LDLFactorization succeeded.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LDLFactorizations.ldl-Union{Tuple{Tp}, Tuple{Ti}, Tuple{T}, Tuple{LinearAlgebra.Symmetric{T, SparseArrays.SparseMatrixCSC{T, Ti}}, Vector{Tp}}} where {T<:Real, Ti<:Integer, Tp<:Integer}","page":"Reference","title":"LDLFactorizations.ldl","text":"S = ldl(A, P, Tf = eltype(A))\nS = ldl(A, P)\nS = ldl(A)\n\nCompute the LDLᵀ factorization of the matrix A with permutation vector P (uses an  AMD permutation by default). Tf should be the element type of the factors, and defaults to eltype(A). This function is equivalent to:\n\nS = ldl_analyze(A)\nldl_factorize!(A, S)\n\nA should either be a upper triangular matrix wrapped with LinearAlgebra's Symmetric  type, or a symmetric matrix (not wrapped with Symmetric).\n\nUsing a non upper triangular matrix wrapped with Symmetric will not give the LDLᵀ factorisation of A.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LDLFactorizations.ldl_analyze-Union{Tuple{Tp}, Tuple{Ti}, Tuple{T}, Tuple{LinearAlgebra.Symmetric{T, SparseArrays.SparseMatrixCSC{T, Ti}}, Vector{Tp}}} where {T<:Real, Ti<:Integer, Tp<:Integer}","page":"Reference","title":"LDLFactorizations.ldl_analyze","text":"LDL = ldl_analyze(A, P, Tf = eltype(A))\nLDL = ldl_analyze(A, P)\nLDL = ldl_analyze(A)\n\nPerform symbolic analysis of the matrix A with permutation vector P (uses an  AMD permutation by default) so it can be reused.  Tf should be the element type of the factors, and defaults to eltype(A). A should be a upper triangular matrix wrapped with LinearAlgebra's Symmetric type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LDLFactorizations.ldl_factorize!-Union{Tuple{Tp}, Tuple{Tn}, Tuple{Ti}, Tuple{Tf}, Tuple{T}, Tuple{LinearAlgebra.Symmetric{T, SparseArrays.SparseMatrixCSC{T, Ti}}, LDLFactorizations.LDLFactorization{Tf, Ti, Tn, Tp}}} where {T<:Real, Tf<:Real, Ti<:Integer, Tn<:Integer, Tp<:Integer}","page":"Reference","title":"LDLFactorizations.ldl_factorize!","text":"ldl_factorize!(A, S)\n\nFactorize A into the S LDLFactorization struct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearAlgebra.ldiv!-Union{Tuple{Tp}, Tuple{Tn}, Tuple{Ti}, Tuple{Tf}, Tuple{T}, Tuple{AbstractVector{T}, LDLFactorizations.LDLFactorization{Tf, Ti, Tn, Tp}, AbstractVector{T}}} where {T<:Real, Tf<:Real, Ti<:Integer, Tn<:Integer, Tp<:Integer}","page":"Reference","title":"LinearAlgebra.ldiv!","text":"ldiv!(y, LDL, b)\n\nIf LDL is the LDLᵀ factorization of A, solves A x = b In place.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearAlgebra.ldiv!-Union{Tuple{Tp}, Tuple{Tn}, Tuple{Ti}, Tuple{Tf}, Tuple{T}, Tuple{LDLFactorizations.LDLFactorization{Tf, Ti, Tn, Tp}, AbstractVector{T}}} where {T<:Real, Tf<:Real, Ti<:Integer, Tn<:Integer, Tp<:Integer}","page":"Reference","title":"LinearAlgebra.ldiv!","text":"ldiv!(LDL, b)\n\nIf LDL is the LDLᵀ factorization of A, solves A x = b and overwrites b with x.\n\n\n\n\n\n","category":"method"},{"location":"#LDLFactorizations.jl","page":"Home","title":"LDLFactorizations.jl","text":"","category":"section"},{"location":"tutorial/#LDLFactorizations.jl-Tutorial","page":"Tutorial","title":"LDLFactorizations.jl Tutorial","text":"","category":"section"},{"location":"tutorial/#A-basic-example","page":"Tutorial","title":"A basic example","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"n = 10\nA0 = rand(n, n)\nA = A0 * A0' + I # A is symmetric positive definite\nb = rand(n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We solve the system A x = b using LDLFactorizations.jl:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using LDLFactorizations, LinearAlgebra\nAu = Symmetric(triu(A), :U) # get upper triangle and apply Symmetric wrapper\nLDL = ldl(Au)\nx = LDL \\ b","category":"page"},{"location":"tutorial/#A-more-performance-focused-example","page":"Tutorial","title":"A more performance-focused example","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We build a problem with sparse arrays.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SparseArrays\nn = 100\n# create create a SQD matrix A:\nA0 = sprand(Float64, n, n, 0.1)\nA1 = A0 * A0' + I\nA = [A1   A0;\n     A0' -A1]\nb = rand(2 * n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now if we want to use the factorization to solve multiple systems that have  the same sparsity pattern as A, we only have to use ldl_analyze once.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Au = Symmetric(triu(A), :U) # get upper triangle and apply Symmetric wrapper\nx = similar(b)\n\nLDL = ldl_analyze(Au) # symbolic analysis\nldl_factorize!(Au, LDL) # factorization\nldiv!(x, LDL, b) # solve in-place (we could use ldiv!(LDL, b) if we want to overwrite b)\n\nAu.data.nzval .+= 1.0 # modify Au without changing the sparsity pattern\nldl_factorize!(Au, LDL) \nldiv!(x, LDL, b)","category":"page"},{"location":"tutorial/#Dynamic-Regularization","page":"Tutorial","title":"Dynamic Regularization","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When the matrix to factorize is (nearly) singular and the factorization encounters (nearly) zero pivots,  if we know the signs of the pivots and if they are clustered by signs (for example, the  n_d first pivots are positive and the other pivots are negative before permuting), we can use:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ϵ = sqrt(eps())\nAu = Symmetric(triu(A), :U)\nLDL = ldl_analyze(Au)\nLDL.tol = ϵ\nLDL.n_d = 10\nLDL.r1 = 2 * ϵ # if any of the n_d first pivots D[i] < ϵ, then D[i] += LDL.r1    \nLDL.r2 = -ϵ # if any of the n - n_d last pivots D[i] < ϵ, then D[i] += LDL.r2 \nldl_factorize!(Au, LDL)","category":"page"}]
}
